Great. I’ll gather examples of prompts and best practices for using large language models (LLMs) to write comprehensive cloud system design documents, covering both functional and non-functional requirements.
I'll compile the insights into a single high-quality English prompt that you can reuse or customize.
I'll let you know when it's ready.


# Prompt Engineering for Cloud System Design Documents

## Introduction

Large Language Models (LLMs) can greatly assist in generating comprehensive cloud system design documents. To get high-quality results, the prompt given to the LLM should clearly define the task, provide context, and outline the expected structure and content. A well-crafted prompt helps ensure the resulting document covers all key aspects of the system – both functional requirements (the features and behaviors) and non-functional requirements (the quality attributes and constraints). By applying prompt engineering best practices, you can guide the LLM to produce a logically structured, technically sound design document that addresses scalability, availability, performance, cost, observability, security, maintainability, compliance, and more.

## Key Sections in a Cloud System Design Document

A cloud system design document typically includes several standard sections. Ensuring the prompt asks for these sections will guide the LLM to structure its output properly. Key sections to request include:

* **Overview/Introduction:** Define the purpose and scope of the document and the target audience. For example, clarify if it’s describing a web application’s architecture on AWS, the goals of the system, and who will read the document (developers, architects, stakeholders). This sets the context for the rest of the document.
* **Architecture Summary:** Provide a high-level system overview, including the major components and how they interact. This often includes an **architecture diagram** (which the LLM can describe or outline). Mention the overall style (e.g. microservices vs monolith) and any key design principles or patterns used. Include a brief description of each component and how data flows between them. For example, a ridesharing app design doc might list the mobile clients, backend services, and database, along with a diagram depicting their interactions.
* **Functional Requirements:** List and describe the system’s features and functionalities. This section should answer *what* the system does. It can be structured as use cases or user stories, or simply as a bullet list of key features with descriptions. Make sure the prompt asks the model to enumerate these clearly so that no major feature is omitted.
* **Non-Functional Requirements:** Detail the quality attributes and constraints the system must meet. These include **performance** (e.g. response times, throughput), **scalability** (ability to handle growth in users or data), **availability/reliability** (uptime targets, failover capabilities), **security** (authentication, authorization, encryption), **maintainability** (code standards, modularity for easier updates), and others. In cloud systems, **cost efficiency** is also a crucial non-functional requirement – it should be considered alongside traditional factors like security and scalability. **Compliance** with regulations or standards (e.g. GDPR, HIPAA) is another important aspect to include. Additionally, **observability** should be covered – this means logging, monitoring, and alerting practices that help in tracking system health and performance. By explicitly listing these categories in the prompt, the LLM will be prompted to address each of them. For example: “Describe how the design ensures scalability, availability, performance, cost-effectiveness, observability (logging/monitoring), security, maintainability, and compliance with any relevant standards.”
* **Technical Stack & Components:** Identify the technologies chosen for each part of the system. This can be organized by tiers – e.g. *Frontend* (frameworks like React or Angular), *Backend* (language and frameworks, e.g. Node.js with Express, or Python with Django), *Database* (SQL or NoSQL database choices), and *Infrastructure/Cloud services* (AWS, Azure, GCP components, Docker/Kubernetes, etc.). The prompt should ask the model to list the tech stack and justify choices if relevant (for instance, “Node.js for its asynchronous support and large ecosystem”). Also describe major system components or modules and their responsibilities – for example, “User Service”, “Order Processing Service”, “Authentication Service”, etc., including any third-party integrations.
* **Detailed Design/Module Design:** For more complex systems, it’s helpful to include a section that dives deeper into important modules or services. The prompt might instruct the LLM to provide details for each module: its purpose, inputs/outputs, dependencies, and an outline of how it works (possibly even pseudo-code or sequence of steps). If applicable, data models or database schema can be described here (or in a dedicated **Database Design** section) with key tables and relationships. Including this level of detail ensures the document is useful for developers who will implement the system.
* **Security Considerations:** While security is a non-functional requirement, it often gets its own section in a design doc. The prompt can request the LLM to consolidate security-related design decisions: e.g. authentication and authorization mechanisms (OAuth2, JWT, role-based access control), data protection measures (encryption in transit and at rest), and how common threats are mitigated (SQL injection, XSS, etc.). This ensures the LLM’s output addresses security thoroughly, beyond just one line in NFRs.
* **Deployment and Operations:** In a cloud context, the design doc should describe how the system will be deployed and managed in production. The prompt can ask for a **deployment architecture** section that outlines the cloud environment (regions, VPC/network setup, container orchestration, CI/CD pipeline, etc.). It should also mention the strategy for scaling (auto-scaling groups, load balancers) and the **observability** stack (monitoring tools like CloudWatch, Prometheus, logging systems, alerting via PagerDuty, etc.). This corresponds to maintainability and reliability aspects and ties back to non-functional requirements like availability and performance.
* **Risks and Mitigations:** A good design document highlights potential **risks** (technical challenges or uncertainties) and how to mitigate them. In the prompt, include a requirement for a “Risks and Mitigation” section. For example, the LLM should list things like “Risk: Unexpected spike in traffic could overwhelm the system – Mitigation: Use auto-scaling and rate limiting” or “Risk: Dependency on third-party API – Mitigation: implement caching and fallback logic.” Including this in the prompt encourages the model to think critically about weak points in the design and ways to address them.
* **Alternatives Considered:** To ensure the design is well-reasoned, the prompt can instruct the LLM to mention any alternative approaches or architectures that were considered and explain why the chosen design is preferred. For instance, it might note “Alternative: Use a monolithic architecture – Rejected due to scalability issues” or “Alternative: Use GraphQL instead of REST – Rejected due to complexity for this use case”. This shows a broader design thinking and documents the rationale behind decisions, which is valuable for stakeholders reviewing the design.
* **Diagrams and Visual Aids:** While an LLM cannot generate actual diagram images, it can be prompted to *describe* what diagrams should illustrate. The prompt can request the model to include references to diagrams (e.g. “Figure 1: High-Level Architecture Diagram showing user, web server, application server, and database”) or even ASCII art or pseudo-diagrams if appropriate. Explicitly mentioning diagrams in the prompt (like “include an architecture diagram and data flow diagram explanation”) will remind the model to allocate part of the answer to describing these visuals. This makes the output more complete, as design docs usually have diagrams for clarity.
* **Future Considerations (Optional):** Some design docs end with future improvements or next steps. You might prompt the LLM to conclude with any assumptions, limitations, or potential future enhancements and scalability plans. This could include notes on features not implemented in the first version, or how the system could evolve (for example, supporting more users, adding multi-region support, etc.). This forward-looking element can demonstrate that the design has room for growth.

By specifying the above sections, you guide the LLM to produce a document that is thorough and well-structured. Each section addresses a different aspect of the system, ensuring both functional specs and cross-cutting concerns are covered.

## Best Practices in Prompt Construction

When crafting the prompt for an LLM, keep these prompt engineering best practices in mind:

* **Assign a Role/Persona:** Clearly define the role of the LLM to shape the style and depth of the response. For example, instruct the model to act as an *“experienced cloud architect and technical writer”*. By leveraging such role-playing, the model will respond with the appropriate expertise, tone, and audience alignment. This ensures the content is written in a knowledgeable and professional manner, suitable for a design document. *(Example: “You are a senior cloud architect writing a system design document...”)*
* **Be Specific and Descriptive:** Provide as much detail in the instructions as possible about what the document should contain and how it should be formatted. LLMs respond better to clearly specified tasks. Outline the expected sections and even sub-points under each section. Mention the desired format (e.g. Markdown with headings for each section, bullet points for lists, etc.) and the level of detail needed (for instance, “include technical justifications and real-world considerations for each decision”). The OpenAI guide emphasizes giving explicit instructions on context, length, format, and style for best results.
* **Structure the Prompt with Sections or Bullet Points:** You can format the prompt itself in a structured way to avoid ambiguity. For instance, after a brief instruction, list the required sections or deliverables in bullet form. This acts as a checklist for the model. Delimiting the instruction (using separators like `"""` or markdown separators) from any example or context you provide is also helpful. An example prompt structure might be:
  **System Description:** *\[brief description of the system]*
  **Task:** *“Draft a system design document for the above system with the following sections: 1) Introduction, 2) Architecture Overview, …”*
  This clearly separates the context from the ask. Providing an example of the desired output format (like showing a sample section header) can further guide the model.
* **Include All Key Requirements in the Prompt:** Don’t assume the model knows to cover a particular non-functional requirement or section – explicitly mention it. If the design must address certain concerns (scalability, security, compliance, etc.), list them in the prompt so the model will remember to include them. For instance, “Ensure the document addresses non-functional requirements such as performance, security, compliance, etc.” (as we will do in the example prompt). This reduces the chance of the model forgetting an important aspect.
* **Use Constraints and Guidance:** You can add constraints like *“If information is not provided, make reasonable assumptions and note them”* or *“Only include technically accurate information”*. You can also guide style, e.g., *“Use a formal and factual tone”* or *“Do not use overly casual language.”* Such constraints help the model maintain the expected quality and tone throughout the document.
* **Iterate and Refine if Needed:** The first draft from the LLM might not be perfect. A best practice is to allow an iterative process. For example, you could prompt the LLM to first output an outline, then provide feedback or more detail, and then have it fill in the sections. Some advanced prompting frameworks even build in an evaluation step where the AI checks its work against a rubric, but a simpler approach is to manually review and ask follow-up prompts. If using an interactive chat, instruct the model that it can ask clarifying questions. The EarlyNode guide suggests appending a line like *“Feel free to ask any questions if you need clarification.”* to let the AI know it can request more info. This can lead to a better final document because the model might identify missing pieces and inquire about them instead of guessing incorrectly.
* **Review and Post-Edit the Output:** Remember that while LLMs can generate a solid first draft of a design doc, human oversight is crucial. Research has shown that AI-generated templates and content often require adjustment to fit the specific project context and organizational standards. The model might produce generic descriptions or overlook subtle project-specific details. Plan to review the document for accuracy and completeness, refining any sections as needed. On the positive side, LLMs can significantly accelerate documentation by providing well-structured initial content for standard sections – you just need to ensure it’s all tuned to your actual system. In your prompt construction, you might not explicitly include this step (since it's more of a workflow), but it's a best practice in using LLMs for technical documentation.

By following these practices – setting a clear role, giving detailed instructions with a structured format, and covering all requirements – you increase the likelihood of the LLM’s output being comprehensive and well-organized. Now, we will combine these insights into a single prompt example.

## Example Prompt for a Cloud System Design Document

Taking into account the above best practices and typical document structure, below is a **reusable prompt** that you can use (or adapt) to have an LLM like ChatGPT generate a cloud system design document. This prompt assumes you will fill in placeholders (indicated by `<...>`) with your specific system details before using it:

> **Role:** *You are an expert cloud systems architect and technical writer.*
> **Task:** *Write a comprehensive **Cloud System Design Document** for the system described below.*
> **System Description:** *"\<brief description of the system, e.g., an e-commerce web application hosted on cloud infrastructure, including key goals or features.>"*
> **Instructions:** The document should be structured in clear sections with Markdown headings and subheadings. Include all of the following sections and details:
>
> 1. **Introduction** – Purpose of the document, scope of the system, and target audience. Provide a brief overview of what the system is and its objectives.
> 2. **Architecture Overview** – High-level description of the system architecture. Describe the overall design (e.g., microservices architecture, layered architecture), major components, and how they interact. Include an explanation of a high-level architecture diagram (e.g., what components/services it shows and how data flows).
> 3. **Functional Requirements** – List the key features and functionalities of the system. For each major feature or use-case, provide a short description of what the system must do. (For example: user registration, order processing, real-time analytics, etc.)
> 4. **Non-Functional Requirements** – Describe the requirements and goals for system qualities:
>
>    * **Scalability:** How the design will handle growth in users or data (horizontal/vertical scaling strategies).
>    * **Availability & Reliability:** Target uptime, redundancy, failover mechanisms, and disaster recovery plans to ensure the system is highly available.
>    * **Performance:** Expected response times, throughput, and any performance testing criteria. How the design meets these (caching, load balancing, etc.).
>    * **Cost Efficiency:** Considerations to minimize cloud costs (efficient resource usage, auto-scaling to match demand, etc.).
>    * **Observability:** Logging, monitoring, and alerting approach to keep the system observable (what tools or services are used for tracking metrics and logs).
>    * **Security:** How the system is secured (authentication, authorization, data encryption in transit and at rest, network security, etc.).
>    * **Maintainability:** Design decisions to ensure the system is maintainable (modular design, use of managed services, coding standards, documentation, etc.).
>    * **Compliance:** Any compliance requirements (such as GDPR, HIPAA, or industry standards) and how the design addresses them.
> 5. **Technical Stack** – Outline the technology stack and cloud services used: e.g., front-end framework, back-end language/framework, databases, cloud provider services (compute, storage, networking), and any other relevant tools or libraries. Explain why certain key technologies were chosen if relevant (for instance, “Using AWS Lambda for scalability and managed infrastructure”).
> 6. **Detailed Design** – Dive into major components or modules of the system: for each component (or service), describe its responsibility, how it works, and its interface/contracts with other components. Include details like data models (if a database is used, describe important tables or data schemas), important algorithms or workflows (possibly with a step-by-step or a sequence diagram description for critical processes), and how components communicate (e.g., REST APIs, message queues). If applicable, break this into subsections (e.g., “6.1 User Service”, “6.2 Order Service”, “6.3 Database Design”, etc.).
> 7. **Security Architecture** – (If not already covered in NFRs) Elaborate on security measures in the design: user identity management, permission roles, handling of sensitive data, protection against common vulnerabilities (SQL injection, XSS, etc.), and any security audits or compliance certifications considered.
> 8. **Deployment & DevOps** – Describe how and where the system will be deployed. Include the cloud hosting environment and architecture (e.g., AWS region, VPC, subnets, container orchestration with Kubernetes or serverless deployment, CI/CD pipeline for automated deployments). Also describe the operational setup: monitoring (which services/tools monitor the system), logging, backups, and disaster recovery strategy. Discuss how the system scales in production (auto-scaling groups, load balancers) and how updates are rolled out with minimal downtime.
> 9. **Risks and Mitigations** – List potential risks or challenges in the design and how to mitigate them. For each risk (such as “High traffic spikes”, “Dependency downtime”, “Security breach risk”), provide the mitigation strategy (like “use rate limiting and auto-scaling”, “implement circuit breakers and retries”, “regular security audits and intrusion detection system”).
> 10. **Alternatives Considered** – Briefly mention any alternative design approaches or technologies that were evaluated. Explain why they were not chosen. (For example: “We considered a monolithic architecture, which would simplify deployment but was rejected due to scalability limitations. The microservices approach was chosen for better modularity and scaling.”)
> 11. **Conclusion** – Provide a short conclusion summarizing how the proposed design meets the requirements and business goals. You may also note any assumptions made during the design and any areas for future expansion or investigation.
>     **Formatting & Style:** Use clear, professional language. Organize content under the appropriate headings. Where helpful, use bullet points or tables (for example, a table of requirements vs. solutions, or a list of services in the tech stack). Ensure the document is self-contained and clearly explains all points. If some details are not provided, make reasonable assumptions to flesh out the document (and state these assumptions). Avoid overly generic statements – tailor the content to the specific system described.

This prompt explicitly instructs the LLM on the structure (sections 1 through 11), the content to include in each section, and the style to use. By following this prompt, the LLM should produce a cloud system design document that covers all functional and non-functional requirements comprehensively, in a well-organized format. Remember to replace the placeholder `<brief description of the system>` with your actual system details or project description before using the prompt. You can further adjust the prompt to add any project-specific concerns or to remove sections that may not apply.

Using a prompt like the above, which encapsulates the best practices and includes detailed guidance, you can reliably generate a solid first draft of a cloud system design document with an LLM. The result should save time and serve as a strong foundation, requiring only minor revisions to finalize the document for your needs.

**Sources:**

* OpenAI Prompt Engineering Guidelines – on providing clear instructions and desired format
* Helicone Prompt Engineering Guide – on using role-playing to shape response style
* EarlyNode – prompt examples for system architects and the tip on clarifying questions
* *AI for Work* Blog – how to structure a System Architecture Document (detailed outline)
* Ar. Aldhafeeri (Medium) – template for system design documents (sections like Requirements, Architecture, etc.)
* LinkedIn (S. Rathnayake) – example of a comprehensive design doc (sections and alternatives considered)
* *The Frugal Architect* – making cost a considered non-functional requirement (and listing NFR examples like availability, scalability, maintainability, compliance)
* Saarinen, *Generative AI in Software Development* (2023) – case study noting ChatGPT’s ability to generate document templates and content, with need for human customization
